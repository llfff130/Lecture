# HUST-USYD 并行编程实践暑期学校 —— 第六讲

## 一、课程主题
- **任务分配与负载平衡**
- **图划分**
- **并行 for 指令的 schedule 子句**
- **实验室练习：矩阵乘法**
- **作业 4**

## 二、任务分配与负载平衡

### （一）理想与实际加速比
- **公式**:$(S = \frac{T_s}{T_p})$
- **理想情况**：使用 \(p\) 个处理单元时，加速比会增加 \(p\) 倍。
- **实际情况**：实际加速比通常小于理想加速比，且随着处理器数量的增加而变得更糟。

### （二）效率低下的原因
1. **单处理器性能不佳**：通常在内存系统中。
2. **并行开销过大**：
   - 同步
   - 通信
   - 冗余计算
3. **负载不平衡**：
   - 不同处理器上的工作量不同
   - 计算和通信
   - 不同计算资源的速度不同（例如，CPU + GPU）

### （三）任务分配策略
- **静态任务分配**：
  - 任务分配给进程/线程是预先确定的。
  - 简单且运行时开销为零。
  - 适用于任务数量可预测的情况。
- **动态任务分配**（动态工作调度或动态负载平衡）：
  - 在运行时根据实际情况动态分配任务。
  - 适用于任务数量不可预测或任务大小不均匀的情况。

## 三、图划分

### （一）图划分的定义
- 给定一个图 \(G = (N, E, W_N, W_E)\)：
  - \(N\)：顶点集合
  - \(E\)：边集合
  - \(W_N\)：顶点权重
  - \(W_E\)：边权重
- 划分目标：
  - 平衡工作负载：每个子图的顶点权重之和大致相等。
  - 最小化通信开销：连接不同子图的边的权重之和最小化。

### （二）图划分的方法

#### 1. 坐标二分法（Coordinate Bisection）
- **原理**：选择一个超平面（例如，垂直于 \(x\) 轴的直线），将顶点分成两部分。
- **步骤**：
  1. 计算所有顶点的质心 \((\bar{x}, \bar{y})\)。
  2. 选择一条通过质心的直线 \(L\)，将顶点分为两组。
  3. 递归地在 \(x\)、\(y\) 和 \(z\) 坐标上进行二分，以优化划分效果。
- **优点**：简单易实现，计算效率高。
- **缺点**：依赖于坐标系统，不同的坐标系统可能导致不同的划分结果。`图二分通常是一个 NP（非确定性多项式）问题`

#### 2. 惯性二分法（Inertial Bisection）
- **原理**：选择一个超平面，使得顶点到该超平面的距离平方和最小。
- **步骤**：
  1. 将原点移动到质心 \((\bar{x}, \bar{y})\)。
  2. 通过旋转坐标，找到一个方向，使得顶点到该方向的距离平方和最小。
  3. 选择一个超平面，将顶点分为两组。
  4. 递归地进行二分，直到达到所需的子图数量。
- **优点**：考虑了顶点的分布，通常能获得更好的划分效果。
- **缺点**：计算复杂度较高，需要求解特征值问题。

## 四、并行 for 指令的 schedule 子句

### （一）schedule 子句的作用
- 描述循环迭代是如何在团队线程之间分配的。

### （二）schedule 子句的类型
1. **schedule(static[, chunk])**
   - 将大小为 “chunk” 的迭代块分配给每个线程。
   - 静态调度在编译时完成。
   - 块大小是预先确定的，可由程序员预测——运行时工作量最少。
   - 例如：
     - schedule(static) — 块划分
     - schedule(static, 1) — 循环划分
2. **schedule(dynamic[, chunk])**
   - 每个线程从队列中抓取 “chunk” 次迭代，直到所有迭代都处理完毕。
   - 动态调度在运行时使用复杂的调度逻辑。
   - 每次迭代的工作量不可预测，高度可变——运行时工作量最多。

## 五、实验室练习：矩阵乘法 $(C = A \times A^T)$

### （一）任务要求
- 编写一个 OpenMP 程序来计算 $(C = A \times A^T)$，假设 \(A\) 的大小为 $(n \times m)$。
- 注意结果矩阵 \(C\) 是一个对称矩阵。
- 我们有 $(c_{ij} = c_{ji})$。
- 为了节省操作量，我们只需要计算上三角的元素，即 $(c_{ij})$ 对于 $(i \leq j)$。
- 编写一个顺序程序，然后添加 OpenMP 指令来并行化程序。
- 你需要考虑负载平衡。

## 六、作业 4

### （一）任务要求
- 编写一个 OpenMP 程序，用于部分主元消元的高斯消元法。
- 通过添加必要的 OpenMP 指令、子句和函数来修订 gepp0.c。

## ------------
### 一、坐标变换
在 ((x, y)) 系统中，设点(P)的极坐标为 $((r, \alpha))$，然后在 $((x', y'))$ 系统中为 $((r, \alpha - \theta))$。

- **坐标变换公式**：
  $$[
  x = r \cos \alpha
  ]$$
  $$[
  y = r \sin \alpha
  ]$$

### 二、惯性二分法步骤

#### （一）移动原点到质心
首先将原点移动到质心 $((\bar{x}, \bar{y}))$，其中：
$[
\bar{x} = \frac{1}{N} \sum_{i=1}^{N} x_i
]$
$[
\bar{y} = \frac{1}{N} \sum_{i=1}^{N} y_i
]$

#### （二）旋转坐标
然后旋转 $((x', y'))$ 坐标 $(\theta)$ 度：
$[
x' = x \cos \theta + y \sin \theta
]$

从 (c) 我们有：
$[
d_i = x_i'
]$

令 $(v = \cos \theta)$ 和 $(w = \sin \theta)$，通过简单的数学运算我们有：
$[
d_i = v(x_i - \bar{x}) + w(y_i - \bar{y})
]$

#### （三）计算惯性矩
令：
$[
u^T = [v, w]
]$
$[
s_{xx} = \sum_{i=1}^{N} (x_i - \bar{x})^2
]$
$[
s_{xy} = \sum_{i=1}^{N} (x_i - \bar{x})(y_i - \bar{y})
]$
$[
s_{yy} = \sum_{i=1}^{N} (y_i - \bar{y})^2
]$

我们有：
$$[
d_i = u^T \begin{bmatrix} s_{xx} & s_{xy} \\ s_{xy} & s_{yy} \end{bmatrix} u
]$$

#### （四）最小化目标函数
由于我们希望最小化 $(\sum d_i^2)$，因此选择 \(u\) 作为最小特征值对应的特征向量。
